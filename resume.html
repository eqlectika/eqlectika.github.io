<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yevgeniy Korobka | Resume</title>
    <style>
        body {
    font-family: 'Georgia', serif;
    line-height: 1.8;
    color: #ffffff;
    background-color: #0B0B45;
    max-width: 850px;
    margin: 0 auto;
    padding: 60px 30px;
    
    /* Новые правила для симметрии */
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}



.content {
    text-align: center;
    margin-bottom: 60px;
    width: 100%;
}

.content p {
    margin-bottom: 2em;
    max-width: 650px; /* Ограничение ширины для стройности колонки */
    margin-left: auto;
    margin-right: auto;
}


        
        canvas {
    display: block;
    position: fixed; /* Используем fixed для фона при прокрутке */
    top: 0;
    left: 0;
    z-index: -1; /* Помещаем за текст */
}

/* Убедимся, что контент резюме имеет относительное позиционирование */
.header, .content, .footer {
    position: relative;
    z-index: 1;
    pointer-events: none; /* Пропускаем клики к фону через пустые места */
}

/* Кнопки и ссылки должны оставаться кликабельными */
.footer a {
    pointer-events: auto;
}


        h3 {
            font-size: 1.8em;
            letter-spacing: 1.5px;
            margin: 0;
            font-weight: normal;
        }

        .footer {
            text-align: center;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            padding-top: 40px;
        }
        .footer a {
            color: #ffffff;
            text-decoration: none;
            font-size: 1.2em;
            transition: opacity 0.3s;
        }
        .footer a:hover {
            opacity: 0.7;
        }
    </style>
</head>
<body>

    <div class="header">
        <img src="me.heic" alt="Yevgeniy Korobka" class="header-img">
        <h3>Yevgeniy Korobka</h3>
    </div>

    <div class="content">
        <p>
            My professional path resembles a movement along a spiral, where each new turn is the mastery of a new element, from the tip of a pencil to the architecture of decentralized networks. I view design, 3D modeling, and hand-drawing not as decoration, but as the foundation of visual thinking, allowing ideas to be embodied in tangible forms. In this space, architecture becomes the assembly point where aesthetics meet precise calculation, creating an environment in which one wants to be "now."
        </p>

        <p>
            The technological stack, including JavaScript, Python, and blockchain-based development, serves as a continuation of this logic in the digital world. Working with financial markets and peer-to-peer programming has taught me to see structure within chaos and to understand that any complex system lives by the laws of rhythm and balance. In blockchain, I find that very honesty of the moment, where a transaction or code is stripped of the layers of the past, existing as an accomplished fact in the present. This allows me to build applications and services that do not simply solve a task but create a stable and transparent ecosystem.
        </p>

        <p>
            In team interaction, I transmit the wisdom of an observer who knows how to notice falsehood or excessive acceleration in time. My ability to synthesize art and high technology gives the collective an advantage—the opportunity to stop and correct the course before inertia becomes critical. I offer not just the execution of tasks, but conscious co-creation, where every algorithm and every line of architecture is aimed at creating a harmonious and meaningful result.
        </p>
    </div>

    <div class="footer">
        <a href="https://t.me/eugenebox">@eugenebox</a>
    </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>

<script>
    // Инициализация сцены с цветом фона из вашего резюме
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0B0B45); 

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 25;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.domElement.style.position = 'fixed';
    renderer.domElement.style.top = '0';
    renderer.domElement.style.left = '0';
    renderer.domElement.style.zIndex = '-1'; // Холст остается за текстом
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xffffff, 1);
    pointLight.position.set(15, 15, 15);
    scene.add(pointLight);

    const denseObjects = [];

    const createDenseObject = (position, velocity) => {
        const geometry = new THREE.IcosahedronGeometry(Math.random() * 0.6 + 0.3, 0);
        const material = new THREE.MeshStandardMaterial({
            color: Math.random() * 0xffffff,
            roughness: 0.3,
            metalness: 0.7
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(position);
        mesh.userData = {
            velocity: velocity,
            scatterVelocity: null
        };
        scene.add(mesh);
        denseObjects.push(mesh);
    };

    window.addEventListener('pointerdown', (event) => {
        // Игнорируем клики, если они приходятся на ссылки в футере
        if (event.target.tagName === 'A') return;

        const mouse = new THREE.Vector2(
            (event.clientX / window.innerWidth) * 2 - 1,
            -(event.clientY / window.innerHeight) * 2 + 1
        );

        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(denseObjects);

        if (intersects.length > 0) {
            const object = intersects[0].object;
            const direction = new THREE.Vector3((Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)).normalize();
            object.userData.scatterVelocity = direction.multiplyScalar(12); 
            object.userData.scatterStart = performance.now();
        } else {
            const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const pos = camera.position.clone().add(dir.multiplyScalar(15));
            const velocity = dir.multiplyScalar(0.25);
            createDenseObject(pos, velocity);
        }
    });

    const applyPhysics = () => {
        for (let i = 0; i < denseObjects.length; i++) {
            for (let j = i + 1; j < denseObjects.length; j++) {
                const objA = denseObjects[i];
                const objB = denseObjects[j];
                const dist = objA.position.distanceTo(objB.position);
                if (dist < 2.0) {
                    const force = objA.position.clone().sub(objB.position).normalize().multiplyScalar(0.015);
                    objA.position.add(force);
                    objB.position.sub(force);
                    if (objA.userData.velocity) objA.userData.velocity.add(force.multiplyScalar(0.5));
                    if (objB.userData.velocity) objB.userData.velocity.sub(force.multiplyScalar(0.5));
                }
            }
            const obj = denseObjects[i];
            if (obj.position.length() > 60) {
                obj.userData.velocity.multiplyScalar(-1);
                obj.position.multiplyScalar(0.98);
            }
        }
    };

    const animate = () => {
        requestAnimationFrame(animate);
        denseObjects.forEach((obj) => {
            if (obj.userData.velocity) obj.position.add(obj.userData.velocity);
            
            if (obj.userData.scatterVelocity) {
                const elapsed = (performance.now() - obj.userData.scatterStart) / 1000;
                if (elapsed > 1.2) {
                    obj.userData.scatterVelocity = null;
                } else {
                    obj.position.add(obj.userData.scatterVelocity.clone().multiplyScalar(1/60));
                }
            }
            obj.rotation.x += 0.01;
            obj.rotation.y += 0.01;
        });
        applyPhysics();
        controls.update();
        renderer.render(scene, camera);
    };

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>

</body>
</html>
