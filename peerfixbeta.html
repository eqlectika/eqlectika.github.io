<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <link rel="manifest" href="manifest.json">
    <title>Decentralized Levitation P2P Node</title>
    <style>

body { 
    font-family: "Courier New"; 
    margin: 0; 
    overflow: hidden; 
    background: #000; 
    color: white; 
    /* Защита от выделения и системных меню */
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
    touch-action: none; 
     /* защита от выделения и системных меню */
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
}

        #control-panel { 
            position: fixed; 
            bottom: 50px; 
            left: 10px; 
            cursor: pointer;
            z-index: 1000; 
        }
        #control-panel > * { margin: 9px 9px; }
        #object-counter {
            position: fixed;
            bottom: 210px;
            left: 20px;
            z-index: 1000;
        }
        #help-link {
            position: fixed;
            bottom: 15px;
            left: 20px;
            z-index: 1000;
            color: white;
            text-decoration: none;
        }
        button { margin-top: 5px; }
    </style>
</head>
<body>
    <div id="control-panel">
        <p id="startNode">Start Node</p>
        <p id="connectNode">Connect to Node</p>
        <p id="toggleMode">Drop</p>
        <p id="toggleMovement">Move</p>
        <p id="withdrawButton">Withdraw</p>
    </div>
    <div id="object-counter">Tockens: 100</div>
    <a id="help-link" href="index.html">Origin</a>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.4.7/peerjs.min.js"></script>
    <script>
            let nodeId = Math.random().toString(36).substr(2, 9);
        let peers = {};
        let objects = [];
        let isThrowMode = true;
        let isFreeMode = false;
        let personalObjects = 100;
        let isMovingForward = false;

        let renderer;
        try {
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
        } catch (err) {
            console.error("WebGL ERROR: " + err.message);
            throw err;
        }

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);
        [[0x0000ff, 10, 0, 0], [0x00ff00, 0, 10, 0], [0xff0000, 0, 0, 10]].forEach(l => {
            const light = new THREE.DirectionalLight(l[0], 1);
            light.position.set(l[1], l[2], l[3]);
            scene.add(light);
        });

        const peer = new Peer(nodeId, {
            config: { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] },
            debug: 1
        });

        peer.on('open', (id) => console.log('Node ID:', id));
        peer.on('connection', (conn) => setupConn(conn));

        function setupConn(conn) {
            peers[conn.peer] = conn;
            conn.on('data', (data) => {
                if (data.type === 'objectCreated') syncObjects([data.object]);
                else if (data.type === 'requestSync') conn.send({ type: 'syncObjects', objects });
                else if (data.type === 'syncObjects') syncObjects(data.objects);
                else if (data.type === 'objectDeleted') deleteObject(data.objectId);
                else if (data.type === 'objectCollected') { personalObjects++; updateObjectCounter(); }
            });
        }

        const localChannel = new BroadcastChannel('p2p-network');
        localChannel.onmessage = (e) => { if (e.data.type === 'sync') syncObjects(e.data.objects); };

        function connectNode() {
            let target = prompt('Enter node ID:');
            if (target) setupConn(peer.connect(target));
        }

        function createObject() {
            if (personalObjects <= 0) return;
            const vector = new THREE.Vector3(0, 0, -1).unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const position = camera.position.clone().add(dir.multiplyScalar(10));
            let object = { id: Math.random().toString(36).substr(2, 9), position: [position.x, position.y, position.z], color: Math.random() * 0xffffff, size: 3 };
            objects.push(object);
            personalObjects--;
            renderObject(object);
            updateObjectCounter();
            Object.values(peers).forEach(conn => conn.send({ type: 'objectCreated', object }));
        }

        function renderObject(object) {
            let mesh = new THREE.Mesh(new THREE.IcosahedronGeometry(object.size), new THREE.MeshPhysicalMaterial({ color: object.color, roughness: 0.4, metalness: 1, opacity: 0.7, transparent: true }));
            mesh.position.set(...object.position);
            mesh.userData.id = object.id;
            scene.add(mesh);
        }

        function deleteObject(objectId) {
            const index = objects.findIndex(obj => obj.id === objectId);
            if (index !== -1) {
                objects.splice(index, 1);
                const mesh = scene.children.find(child => child.userData.id === objectId);
                if (mesh) scene.remove(mesh);
                updateObjectCounter();
            }
        }

        function syncObjects(newObjects) {
            newObjects.forEach(obj => { if (!objects.some(o => o.id === obj.id)) { objects.push(obj); renderObject(obj); } });
        }

        function updateObjectCounter() {
            document.getElementById('object-counter').innerText = `Objects: ${personalObjects}`;
        }

        // --- Единое Управление (Pointer Events) ---
        let isDragging = false, isRotating = false;
        let previousMousePosition = { x: 0, y: 0, midX: null, midY: null };
        let cameraRotationVelocity = { x: 0, y: 0 };
        let cameraPositionVelocity = { x: 0, y: 0 };
        let cameraZoomVelocity = 0;
        let activePointers = [];
        let lastPinchDist = 0;
        const damping = 0.95;

        window.addEventListener('pointerdown', (e) => {
            if (e.target.closest('#control-panel') || e.target.closest('#help-link')) return;
            activePointers.push(e);
            previousMousePosition.x = e.clientX;
            previousMousePosition.y = e.clientY;

            if (e.pointerType === 'mouse') {
                if (e.button === 2) isDragging = true;
                else if (e.button === 0) isRotating = true;
            } else if (activePointers.length === 1) {
                isRotating = true;
            }

            if (activePointers.length === 1 && !isFreeMode) {
                if (isThrowMode) createObject(); else pickUpObject(e);
            }
        });

        window.addEventListener('pointermove', (e) => {
            const idx = activePointers.findIndex(p => p.pointerId === e.pointerId);
            if (idx === -1) return;
            activePointers[idx] = e;

            if (activePointers.length === 1) {
                cameraRotationVelocity.x = (e.clientY - previousMousePosition.y) * 0.001;
                cameraRotationVelocity.y = (e.clientX - previousMousePosition.x) * 0.001;
            } else if (activePointers.length === 2) {
                const p1 = activePointers[0], p2 = activePointers[1];
                const dist = Math.sqrt(Math.pow(p1.clientX - p2.clientX, 2) + Math.pow(p1.clientY - p2.clientY, 2));
                if (lastPinchDist > 0) cameraZoomVelocity = (lastPinchDist - dist) * 0.05;
                lastPinchDist = dist;

                const midX = (p1.clientX + p2.clientX) / 2;
                const midY = (p1.clientY + p2.clientY) / 2;
                if (previousMousePosition.midX !== null) {
                    cameraPositionVelocity.x = -(midX - previousMousePosition.midX) * 0.02;
                    cameraPositionVelocity.y = (midY - previousMousePosition.midY) * 0.02;
                }
                previousMousePosition.midX = midX;
                previousMousePosition.midY = midY;
            }
            previousMousePosition.x = e.clientX;
            previousMousePosition.y = e.clientY;
        });

        window.addEventListener('pointerup', (e) => {
            activePointers = activePointers.filter(p => p.pointerId !== e.pointerId);
            if (activePointers.length < 2) { lastPinchDist = 0; previousMousePosition.midX = null; }
            isDragging = isRotating = false;
        });

        window.addEventListener('wheel', (e) => { cameraZoomVelocity = e.deltaY * 0.02; }, { passive: true });
        window.addEventListener('contextmenu', e => e.preventDefault());

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function pickUpObject(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children);
            if (intersects.length > 0) {
                const objectId = intersects[0].object.userData.id;
                deleteObject(objectId);
                personalObjects++;
                updateObjectCounter();
                Object.values(peers).forEach(conn => { if (conn.open) { conn.send({ type: 'objectDeleted', objectId }); conn.send({ type: 'objectCollected' }); } });
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            camera.position.x += cameraPositionVelocity.x;
            camera.position.y += cameraPositionVelocity.y;
            cameraPositionVelocity.x *= damping; cameraPositionVelocity.y *= damping;
            camera.rotation.x += cameraRotationVelocity.x;
            camera.rotation.y += cameraRotationVelocity.y;
            cameraRotationVelocity.x *= damping; cameraRotationVelocity.y *= damping;

            if (Math.abs(cameraZoomVelocity) > 0.01) {
                camera.fov += cameraZoomVelocity;
                camera.fov = Math.max(20, Math.min(100, camera.fov));
                camera.updateProjectionMatrix();
                cameraZoomVelocity *= damping;
            }
            if (isMovingForward) camera.translateZ(-0.1);
            
            // Repel & Rotate
            scene.children.forEach(mesh => {
                if (mesh.userData.id) {
                    mesh.rotation.x += 0.01; mesh.rotation.y += 0.01;
                    const dist = mesh.position.distanceTo(camera.position);
                    if (dist < 12) {
                        const dir = mesh.position.clone().sub(camera.position).normalize();
                        mesh.position.add(dir.multiplyScalar(12 - dist));
                    }
                }
            });
            renderer.render(scene, camera);
        }

        document.getElementById('startNode').onclick = () => alert('Node ID: ' + nodeId);
        document.getElementById('connectNode').onclick = connectNode;
        document.getElementById('toggleMode').onclick = (e) => {
            if (isFreeMode) { isFreeMode = false; isThrowMode = true; e.target.innerText = 'Throw'; }
            else if (isThrowMode) { isThrowMode = false; e.target.innerText = 'Pick Up'; }
            else { isFreeMode = true; e.target.innerText = 'Free'; }
        };
        document.getElementById('toggleMovement').onclick = (e) => {
            isMovingForward = !isMovingForward;
            e.target.innerText = isMovingForward ? 'Stop' : 'Go';
        };

        animate();

    </script>
</body>
</html>
