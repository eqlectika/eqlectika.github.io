<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Polarity Universe: The Nomad Era</title>
    <link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&display=swap" rel="stylesheet">
    <style>
        * { -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; outline: none; -webkit-tap-highlight-color: transparent; }
        body { touch-action: none; margin: 0; overflow: hidden; background: #000; font-family: 'Luckiest Guy', cursive; }
        .top-control, .control-button { position: fixed; z-index: 1000; cursor: pointer; color: #fff; text-transform: uppercase; font-size: 20px; }
        .mode-toggle { left: 3%; top: 20px; }
        .strike-button { right: 3%; top: 20px; }
        .logo-link { left: 50%; transform: translateX(-50%); top: 15px; }
        .logo-image { height: 48px; opacity: 0.8; }
        .further-button { left: 3%; bottom: 20px; }
        .closer-button { right: 3%; bottom: 20px; }
    </style>
</head>
<body>
    <div class="top-control mode-toggle" id="main-mode">Create</div>
    <div class="top-control strike-button" id="btn-strike">Strike</div>
    <div class="top-control logo-link" onclick="location.href='index.html'"><img src="logo.png" class="logo-image"></div>
    <div class="control-button further-button" id="btn-bypass">Bypass</div>
    <div class="control-button closer-button" id="btn-fly">Fly</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Проверка фундаментальных констант
    if (typeof THREE === 'undefined') {
        document.body.innerHTML = '<div style="color:white;text-align:center;margin-top:20%;">Vital Spark Error: THREE is not defined. Check your connection.</div>';
    }

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xffffff, 1.2, 2000);
    camera.add(pointLight);
    scene.add(camera);

    let target = new THREE.Vector3(0, 0, 0);
    let zoomDist = 300;
    let rotationQuat = new THREE.Quaternion();
    let isDragging = false;
    let prevMouse = { x: 0, y: 0 };
    let rotationVelocity = new THREE.Vector2(0, 0);
    let zoomVelocity = 0;

    const GRID = 50;
    const cubesMap = new Map();
    let mode = 'Create', isBypass = false, isFly = false;
    let flySpeed = 0, nomadSteps = 0;
    const colors = [0xff4444, 0x44ff44, 0x4444ff];

    let activePointers = new Map();
    let initialPinchDist = 0;

    function setFaceStyle(m, s) {
        m.material.color.setHex(colors[s % 3]);
        m.material.opacity = (s < 6) ? 0.4 : 1.0;
        m.material.metalness = ((s >= 3 && s < 6) || s >= 9) ? 0.9 : 0.1;
        m.material.roughness = ((s >= 3 && s < 6) || s >= 9) ? 0.2 : 0.8;
        m.material.transparent = true;
        m.material.needsUpdate = true;
    }

    function buildCube(pos) {
        const key = `${Math.round(pos.x)},${Math.round(pos.y)},${Math.round(pos.z)}`;
        if (cubesMap.has(key)) return;

        const group = new THREE.Group();
        group.position.copy(pos);
        const faces = [
            {n:[1,0,0], r:[0,1.57,0]}, {n:[-1,0,0], r:[0,-1.57,0]},
            {n:[0,1,0], r:[-1.57,0,0]}, {n:[0,-1,0], r:[1.57,0,0]},
            {n:[0,0,1], r:[0,0,0]}, {n:[0,0,-1], r:[0,3.14,0]}
        ];

        faces.forEach(d => {
            const neighborPos = pos.clone().add(new THREE.Vector3(...d.n).multiplyScalar(GRID));
            const nKey = `${Math.round(neighborPos.x)},${Math.round(neighborPos.y)},${Math.round(neighborPos.z)}`;
            const neighbor = cubesMap.get(nKey);

            if (neighbor) {
                const invN = [-d.n[0], -d.n[1], -d.n[2]];
                const backFace = neighbor.children.find(f => 
                    f.userData.normal && f.userData.normal.x === invN[0] && 
                    f.userData.normal.y === invN[1] && f.userData.normal.z === invN[2]
                );
                if (backFace) neighbor.remove(backFace);
            } else {
                const mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(GRID, GRID), new THREE.MeshStandardMaterial({side: THREE.DoubleSide}));
                mesh.position.set(d.n[0]*GRID/2, d.n[1]*GRID/2, d.n[2]*GRID/2);
                mesh.rotation.set(d.r[0], d.r[1], d.r[2]);
                mesh.userData = { stage: 0, normal: new THREE.Vector3(...d.n), isFace: true };
                setFaceStyle(mesh, 0);
                group.add(mesh);
            }
        });

        scene.add(group);
        cubesMap.set(key, group);
    }

    window.addEventListener('contextmenu', e => e.preventDefault());

    renderer.domElement.addEventListener('pointerdown', e => {
        activePointers.set(e.pointerId, e);
        isDragging = true;
        prevMouse = { x: e.clientX, y: e.clientY };
        if (activePointers.size === 1) startHold(e);
        else if (activePointers.size === 2) {
            const pts = Array.from(activePointers.values());
            initialPinchDist = Math.hypot(pts[0].clientX - pts[1].clientX, pts[0].clientY - pts[1].clientY);
        }
    });

    window.addEventListener('pointermove', e => {
        if (!isDragging) return;
        activePointers.set(e.pointerId, e);

        if (activePointers.size === 1) {
            const dx = e.clientX - prevMouse.x;
            const dy = e.clientY - prevMouse.y;
            if (e.buttons === 2 || e.shiftKey) {
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(rotationQuat);
                const up = new THREE.Vector3(0, 1, 0).applyQuaternion(rotationQuat);
                target.add(right.multiplyScalar(-dx * 0.6)).add(up.multiplyScalar(dy * 0.6));
            } else {
                rotationVelocity.x = dx * 0.005;
                rotationVelocity.y = dy * 0.005;
            }
            prevMouse = { x: e.clientX, y: e.clientY };
        } else if (activePointers.size === 2) {
            e.preventDefault();
            const pts = Array.from(activePointers.values());
            const dist = Math.hypot(pts[0].clientX - pts[1].clientX, pts[0].clientY - pts[1].clientY);
            zoomVelocity -= (dist - initialPinchDist) * 0.2;
            initialPinchDist = dist;
        }
    }, { passive: false });

    window.addEventListener('pointerup', e => {
        if (activePointers.size === 1) {
            if (Math.abs(e.clientX - (prevMouse.x || 0)) < 5) handleTap(e);
        }
        activePointers.delete(e.pointerId);
        if (activePointers.size === 0) { isDragging = false; endHold(); }
    });

    window.addEventListener('wheel', e => { 
        e.preventDefault();
        zoomVelocity += e.deltaY * 0.03; 
    }, { passive: false });

    let holdTimer;
    const startHold = (e) => {
        holdTimer = setTimeout(() => {
            const ray = new THREE.Raycaster();
            const m = new THREE.Vector2((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
            ray.setFromCamera(m, camera);
            const hit = ray.intersectObjects(scene.children, true).find(h => h.object.userData.isFace);
            if (hit && mode === 'Create') {
                buildCube(hit.object.parent.position.clone().add(hit.object.userData.normal.clone().multiplyScalar(GRID)));
                nomadSteps++;
            }
        }, 600);
    };
    const endHold = () => clearTimeout(holdTimer);

    const handleTap = (e) => {
        const ray = new THREE.Raycaster();
        const m = new THREE.Vector2((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
        ray.setFromCamera(m, camera);
        const hit = ray.intersectObjects(scene.children, true).find(h => h.object.userData.isFace);
        if (hit) {
            if (mode === 'Delete') {
                hit.object.parent.remove(hit.object);
                nomadSteps++;
            } else {
                hit.object.userData.stage = (hit.object.userData.stage + 1) % 12;
                setFaceStyle(hit.object, hit.object.userData.stage);
            }
        }
    };

    const bgCanvas = document.createElement('canvas');
    bgCanvas.width = 2; bgCanvas.height = 2;
    const bgCtx = bgCanvas.getContext('2d');
    const bgTexture = new THREE.CanvasTexture(bgCanvas);
    scene.background = bgTexture;

    let ghostP = new THREE.Vector3(0, 0, 0);
    function nomadAction() {
        if (nomadSteps > 0) {
            const d = [new THREE.Vector3(1,0,0), new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,1)][Math.floor(Math.random()*3)];
            ghostP.add(d.multiplyScalar(GRID * (Math.random()>0.5?1:-1)));
            buildCube(ghostP); nomadSteps--;
        }
    }

    const animate = (t) => {
        if (!isDragging) rotationVelocity.multiplyScalar(0.9);
        zoomVelocity *= 0.85;

        const qX = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), rotationVelocity.y);
        const qY = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), rotationVelocity.x);
        rotationQuat.multiplyQuaternions(qY, rotationQuat).multiply(qX);

        zoomDist = Math.max(50, Math.min(zoomDist + zoomVelocity, 8000));
        
        if (isFly) flySpeed = Math.min(flySpeed + 0.2, 8);
        else flySpeed *= 0.9;
        target.add(new THREE.Vector3(0,0,-1).applyQuaternion(rotationQuat).multiplyScalar(flySpeed));

        camera.position.copy(target).add(new THREE.Vector3(0,0,zoomDist).applyQuaternion(rotationQuat));
        camera.lookAt(target);
        pointLight.position.copy(camera.position);

        const c = Math.floor(Math.sin(t*0.0005)*20 + 60);
        bgCtx.fillStyle = `rgb(${c},${c-10},${c+20})`; bgCtx.fillRect(0,0,2,2); bgTexture.needsUpdate = true;
        
        nomadAction();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    };

    document.getElementById('main-mode').onclick = (e) => { mode = (mode==='Create'?'Delete':'Create'); e.target.innerText = mode; };
    document.getElementById('btn-bypass').onclick = (e) => { isBypass = !isBypass; e.target.innerText = isBypass?'Stop':'Bypass'; };
    document.getElementById('btn-fly').onclick = (e) => { isFly = !isFly; e.target.innerText = isFly?'Stop':'Fly'; };
    document.getElementById('btn-strike').onclick = () => {
        cubesMap.forEach((g, k) => { if (g.position.distanceTo(target) < GRID*2) { scene.remove(g); cubesMap.delete(k); } });
    };

    buildCube(new THREE.Vector3(0,0,0));
    animate(0);
</script>



</body>
</html>
