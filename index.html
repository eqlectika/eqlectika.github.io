<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<link rel="manifest" href="manifest.json">
<title>Core Menu</title>
<link href="https://fonts.googleapis.com/css2?family=Arizonia&display=swap" rel="stylesheet">

<style>

body { 
    margin: 0; 
    padding: 0; 
    overflow: hidden; 
    background-color: #000088; 
    font-family: helvetica; serif;
    touch-action: none;

    /* защита от выделения и системных меню */
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
}

#ui-layer { 
    position: absolute;
    inset: 0;
    z-index: 10;
    pointer-events: none;
}

/* ----- Меню ----- */
nav {
    position: absolute;
    top: 50%;
    left: 3%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 8px ;
    text-align: left;
    pointer-events: none;
}

/* ----- Пункты ----- */
.menu-item { 
    text-decoration: none;
    color: #ffffff;
    font-size: 20px;
    letter-spacing: 0px;
    opacity: 0.8;
    white-space: nowrap;

    pointer-events: auto;
    cursor: pointer;

    transition: transform 0.2s ease, color 0.2s ease;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5); 
}

.menu-item:hover {
    color: #ffeb3b;
    transform: scale(1.08);
}

/* ----- Логотип внутри меню ----- */
.logo {
    max-width: 48px;
    height: auto;
    opacity: 0.8;
margin-top: 10px;;
    pointer-events: auto;
    display: block;
}

/* ----- Canvas ----- */
canvas {
    position: absolute;
    inset: 0;
    z-index: 1;
    display: block;
}

</style>
</head>

<body>

<div id="ui-layer">
    <nav>
        <a href="3d.html" class="menu-item">3D</a>
        <a href="smart.html" class="menu-item">Metrics</a>
        <a href="book.html" class="menu-item">Book</a>
        <a href="flash.html" class="menu-item">Flash</a>
        <a href="orbit.html" class="menu-item">System</a>
        <a href="code.html" class="menu-item">Code</a>
        <a href="size.html" class="menu-item">Size</a>
        <a href="peer.html" class="menu-item">Peer</a>
        <a href="telegraph.html" class="menu-item">Telegraph</a>

        <!-- Логотип внутри меню -->
        <a href="index.html">
            <img src="logo.png" alt="Logo" class="logo">
        </a>

        <a href="resume.html" class="menu-item">About</a>
    </nav>
</div> 

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>

<script>
/* ================== СЦЕНА ================== */
const scene = new THREE.Scene();
const colorStart = new THREE.Color(0x000088);
const colorEnd   = new THREE.Color(0x000000);
scene.background = colorStart.clone();

/* ================== КАМЕРА ================== */
const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.z = 35;

/* ================== РЕНДЕР ================== */
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ================== КОНТРОЛЫ ================== */
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* ================== СВЕТ ================== */
scene.add(new THREE.AmbientLight(0xffffff, 0.4));

[
    [0xff0000,  20,  15, 25],
    [0x00ff00, -20,  15, 25],
    [0x0000ff,   0, -25, 25]
].forEach(l => {
    const p = new THREE.PointLight(l[0], 2.5, 150);
    p.position.set(l[1], l[2], l[3]);
    scene.add(p);
});

/* ================== ПАРАМЕТРЫ ================== */
const denseObjects = [];
let previewObject = null;
let directionLine = null;
let isHolding = false;

const mouse = new THREE.Vector2();

const maxScale     = 3.5;
const growthSpeed  = 0.03;
const pulseSpeed   = 0.08;

const minOpacity = 0.25;
const maxOpacity = 0.9;

const breakSpeed = 0.35;

/* ================== ЗВУК ================== */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playLaunchSound(power) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.type = "sawtooth";
    osc.frequency.value = 180 + power * 220;

    gain.gain.setValueAtTime(0.001, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.15, audioCtx.currentTime + 0.03);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.25);

    osc.connect(gain);
    gain.connect(audioCtx.destination);

    osc.start();
    osc.stop(audioCtx.currentTime + 0.26);
}

/* ================== РАЗРЫВ ================== */
function explodeObject(obj) {
    const fragments = 8;
    const basePos = obj.position.clone();
    const baseMat = obj.material;

    for (let i = 0; i < fragments; i++) {
        const geom = new THREE.IcosahedronGeometry(0.25, 0);
        const mat  = baseMat.clone();

        const piece = new THREE.Mesh(geom, mat);
        piece.position.copy(basePos);

        piece.userData.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.25,
            (Math.random() - 0.5) * 0.25,
            (Math.random() - 0.5) * 0.25
        );

        piece.userData.canBreak = false; // фрагменты не рвутся
        scene.add(piece);
        denseObjects.push(piece);
    }

    scene.remove(obj);
}

/* ================== POINTER DOWN ================== */
window.addEventListener("pointerdown", e => {
    if (e.cancelable) e.preventDefault();
    isHolding = true;

    mouse.set(
        (e.clientX / innerWidth) * 2 - 1,
        -(e.clientY / innerHeight) * 2 + 1
    );

    const v = new THREE.Vector3(mouse.x, mouse.y, 0.5).unproject(camera);
    const dir = v.sub(camera.position).normalize();
    const pos = camera.position.clone().add(dir.multiplyScalar(10));

    const geom = new THREE.IcosahedronGeometry(0.5, 0);
    const mat = new THREE.MeshPhongMaterial({
        color: Math.random() * 0xffffff,
        transparent: true,
        opacity: minOpacity,
        shininess: 140,
        side: THREE.DoubleSide
    });

    previewObject = new THREE.Mesh(geom, mat);
    previewObject.position.copy(pos);
    previewObject.scale.setScalar(0.3);
    previewObject.userData.direction = dir;

    scene.add(previewObject);

    directionLine = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([camera.position.clone(), pos.clone()]),
        new THREE.LineBasicMaterial({ transparent: true, opacity: 0.4 })
    );
    scene.add(directionLine);
}, { passive: false });

/* ================== POINTER UP ================== */
window.addEventListener("pointerup", () => {
    if (!previewObject) return;
    isHolding = false;

    const scale = previewObject.scale.x;
    const speed = 0.04 + scale * 0.05;

    previewObject.userData.velocity =
        previewObject.userData.direction.clone().multiplyScalar(speed);

    previewObject.userData.canBreak = false;

    playLaunchSound(scale / maxScale);

    denseObjects.push(previewObject);
    previewObject = null;

    if (directionLine) {
        scene.remove(directionLine);
        directionLine = null;
    }
});

/* ================== АНИМАЦИЯ ================== */
function animate() {
    requestAnimationFrame(animate);

    const t = performance.now() * 0.0002;
    scene.background.lerpColors(colorEnd, colorStart, (Math.sin(t) + 1) / 2);

    for (let i = denseObjects.length - 1; i >= 0; i--) {
        const obj = denseObjects[i];
        if (!obj.userData.velocity) continue;

        obj.position.add(obj.userData.velocity);
        obj.userData.velocity.multiplyScalar(0.995);

        obj.rotation.x += 0.01;
        obj.rotation.y += 0.015;

        if (!obj.userData.canBreak) {
            obj.userData.canBreak = true;
        } else if (obj.userData.velocity.length() > breakSpeed) {
            explodeObject(obj);
            denseObjects.splice(i, 1);
            continue;
        }

        if (obj.position.length() > 70) {
            obj.userData.velocity.multiplyScalar(-1);
        }
    }

    /* превью */
    if (isHolding && previewObject) {
        let s = previewObject.scale.x;
        if (s < maxScale) s += growthSpeed;

        const pulse = Math.sin(performance.now() * 0.01) * pulseSpeed;
        previewObject.scale.setScalar(s + pulse);

        const k = THREE.MathUtils.clamp(s / maxScale, 0, 1);
        previewObject.material.opacity =
            THREE.MathUtils.lerp(maxOpacity, minOpacity, k);

        previewObject.rotation.x += 0.03;
        previewObject.rotation.y += 0.025;

        const arr = directionLine.geometry.attributes.position.array;
        arr[3] = previewObject.position.x;
        arr[4] = previewObject.position.y;
        arr[5] = previewObject.position.z;
        directionLine.geometry.attributes.position.needsUpdate = true;
    }

    controls.update();
    renderer.render(scene, camera);
}

/* ================== RESIZE ================== */
window.addEventListener("resize", () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});

animate();
</script>

</body>
</html>