<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<link rel="manifest" href="manifest.json">
<title>Core Menu</title>
<link href="https://fonts.googleapis.com/css2?family=Arizonia&display=swap" rel="stylesheet">

<style>

body { 
    margin: 0; 
    padding: 0; 
    overflow: hidden; 
    background-color: #000088; 
    font-family: helvetica; serif;
    touch-action: none;

    /* защита от выделения и системных меню */
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
}

#ui-layer { 
    position: absolute;
    inset: 0;
    z-index: 10;
    pointer-events: none;
}

/* ----- Меню ----- */
nav {
    position: absolute;
    top: 50%;
    left: 3%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 8px ;
    text-align: left;
    pointer-events: none;
}

/* ----- Пункты ----- */
.menu-item { 
    text-decoration: none;
    color: #ffffff;
    font-size: 20px;
    letter-spacing: 0px;
    opacity: 0.8;
    white-space: nowrap;

    pointer-events: auto;
    cursor: pointer;

    transition: transform 0.2s ease, color 0.2s ease;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5); 
}

.menu-item:hover {
    color: #ffeb3b;
    transform: scale(1.08);
}

/* ----- Логотип внутри меню ----- */
.logo {
    max-width: 48px;
    height: auto;
    opacity: 0.8;
margin-top: 10px;;
    pointer-events: auto;
    display: block;
}

/* ----- Canvas ----- */
canvas {
    position: absolute;
    inset: 0;
    z-index: 1;
    display: block;
}

</style>
</head>

<body>

<div id="ui-layer">
    <nav>
        <a href="3d.html" class="menu-item">3D</a>
        <a href="smart.html" class="menu-item">Metrics</a>
        <a href="book.html" class="menu-item">Book</a>
        <a href="flash.html" class="menu-item">Flash</a>
        <a href="orbit.html" class="menu-item">System</a>
        <a href="code.html" class="menu-item">Code</a>
        <a href="size.html" class="menu-item">Size</a>
        <a href="peer.html" class="menu-item">Peer</a>
        <a href="telegraph.html" class="menu-item">Telegraph</a>

        <!-- Логотип внутри меню -->
        <a href="index.html">
            <img src="logo.png" alt="Logo" class="logo">
        </a>

        <a href="resume.html" class="menu-item">About</a>
    </nav>
</div> 

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>

<script>
/* ---------- Сцена ---------- */
const scene = new THREE.Scene();
const colorStart = new THREE.Color(0x000088);
const colorEnd   = new THREE.Color(0x000000);
scene.background = colorStart.clone();

/* ---------- Камера ---------- */
const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.z = 35;

/* ---------- Рендер ---------- */
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ---------- Контролы ---------- */
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* ---------- Свет ---------- */
scene.add(new THREE.AmbientLight(0xffffff, 0.4));
[
    [0xff0000,  20,  15, 25],
    [0x00ff00, -20,  15, 25],
    [0x0000ff,   0, -25, 25]
].forEach(l => {
    const p = new THREE.PointLight(l[0], 2.5, 150);
    p.position.set(l[1], l[2], l[3]);
    scene.add(p);
});

/* ---------- Параметры ---------- */
const denseObjects = [];
let previewObject = null;
let directionLine = null;
let isHolding = false;

const mouse = new THREE.Vector2();

const maxScale = 3.5;
const growthSpeed = 0.03;
const pulseSpeed = 0.08;
const minOpacity = 0.25;
const maxOpacity = 0.9;

/* расталкивание */
const repelRadiusSq = 4.0;
const repelStrength = 0.002;
const boundsSq = 65 * 65;

/* ---------- Pointer Down ---------- */
window.addEventListener('pointerdown', e => {
    if (e.cancelable) e.preventDefault();
    isHolding = true;

    mouse.set(
        (e.clientX / innerWidth) * 2 - 1,
        -(e.clientY / innerHeight) * 2 + 1
    );

    const v = new THREE.Vector3(mouse.x, mouse.y, 0.5).unproject(camera);
    const dir = v.sub(camera.position).normalize();
    const pos = camera.position.clone().add(dir.multiplyScalar(10));

    const geom = new THREE.IcosahedronGeometry(0.5, 0);
    const mat = new THREE.MeshPhongMaterial({
        color: Math.random() * 0xffffff,
        transparent: true,
        opacity: minOpacity,
        shininess: 140,
        side: THREE.DoubleSide
    });

    previewObject = new THREE.Mesh(geom, mat);
    previewObject.position.copy(pos);
    previewObject.scale.setScalar(0.3);
    previewObject.userData.direction = dir;
    scene.add(previewObject);

    directionLine = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([camera.position.clone(), pos.clone()]),
        new THREE.LineBasicMaterial({ transparent: true, opacity: 0.4 })
    );
    scene.add(directionLine);
}, { passive: false });

/* ---------- Pointer Up ---------- */
window.addEventListener('pointerup', () => {
    if (!previewObject) return;
    isHolding = false;

    const scale = previewObject.scale.x;
    const speed = 0.04 + scale * 0.05;

    previewObject.userData.velocity =
        previewObject.userData.direction.clone().multiplyScalar(speed);

    denseObjects.push(previewObject);
    previewObject = null;

    if (directionLine) {
        scene.remove(directionLine);
        directionLine = null;
    }
});

/* ---------- Анимация ---------- */
function animate() {
    requestAnimationFrame(animate);

    /* фон */
    const t = performance.now() * 0.0002;
    scene.background.lerpColors(colorEnd, colorStart, (Math.sin(t) + 1) / 2);

    /* объекты + расталкивание */
    for (let i = 0; i < denseObjects.length; i++) {
        const a = denseObjects[i];
        a.position.add(a.userData.velocity);
        a.userData.velocity.multiplyScalar(0.998);
        a.rotation.x += 0.01;
        a.rotation.y += 0.01;

        if (a.position.lengthSq() > boundsSq) {
            a.userData.velocity.multiplyScalar(-1);
        }

        for (let j = i + 1; j < denseObjects.length; j++) {
            const b = denseObjects[j];
            const dx = a.position.x - b.position.x;
            const dy = a.position.y - b.position.y;
            const dz = a.position.z - b.position.z;
            const d2 = dx*dx + dy*dy + dz*dz;
            if (d2 > repelRadiusSq) continue;

            const f = repelStrength / (d2 + 0.0001);
            a.userData.velocity.x += dx * f;
            a.userData.velocity.y += dy * f;
            a.userData.velocity.z += dz * f;
            b.userData.velocity.x -= dx * f;
            b.userData.velocity.y -= dy * f;
            b.userData.velocity.z -= dz * f;
        }
    }

    /* превью */
    if (isHolding && previewObject) {
        let s = previewObject.scale.x;
        if (s < maxScale) s += growthSpeed;
        const pulse = Math.sin(performance.now() * 0.01) * pulseSpeed;
        previewObject.scale.setScalar(s + pulse);

        const k = THREE.MathUtils.clamp(s / maxScale, 0, 1);
        previewObject.material.opacity =
            THREE.MathUtils.lerp(maxOpacity, minOpacity, k);

        previewObject.rotation.x += 0.03;
        previewObject.rotation.y += 0.02;

        const arr = directionLine.geometry.attributes.position.array;
        arr[3] = previewObject.position.x;
        arr[4] = previewObject.position.y;
        arr[5] = previewObject.position.z;
        directionLine.geometry.attributes.position.needsUpdate = true;
    }

    controls.update();
    renderer.render(scene, camera);
}

animate();

/* ---------- Resize ---------- */
window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>