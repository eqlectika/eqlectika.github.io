<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<link rel="manifest" href="manifest.json">
<title>Virtual Sandbox</title>
<link href="https://fonts.googleapis.com/css2?family=Arizonia&display=swap" rel="stylesheet">

<style>

body { 
    margin: 0; 
    padding: 0; 
    overflow: hidden; 
    background-color: #000088; 
    font-family: helvetica; serif;
    touch-action: none;

    /* защита от выделения и системных меню */
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
}

#ui-layer { 
    position: absolute;
    inset: 0;
    z-index: 10;
    pointer-events: none;
    display: flex;
    flex-direction: column;
    justify-content: center; /* Центрирует всё содержимое (лого + nav) по вертикали */
    padding-left: 3%;
}

nav {
    display: flex;
    flex-direction: column;
    gap: 8px;
    text-align: left;
    pointer-events: none;
    width: fit-content;
}

/* Явно разрешаем клики только там, где есть контент */
.logo, .menu-item, .submenu {
    pointer-events: auto;
}

/* ----- Пункты ----- */
.menu-item { 
    text-decoration: none;
    color: #ffffff;
    font-size: 18px;
    letter-spacing: 0px;
    opacity: 0.8;
    white-space: nowrap;
    padding-left: 2px;
    pointer-events: auto;
    cursor: pointer;

    transition: transform 0.2s ease, color 0.2s ease;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5); 
}

.menu-item:hover {
    color: #ffeb3b;
    transform: scale(1.08);
}

/* ЕДИНЫЙ БЛОК ДЛЯ КОНТЕЙНЕРА И ПОДМЕНЮ */
/* ОБНОВЛЕННЫЙ БЛОК КОНТЕЙНЕРА */
.menu-item-container {
    display: flex;
    flex-direction: row; 
    align-items: center;
    position: relative; /* Теперь это якорь для подменю */
    width: fit-content; /* Контейнер больше не растягивается на всю ширину */
}

/* ОБНОВЛЕННЫЙ БЛОК ПОДМЕНЮ */
.submenu {
    display: none;
    position: absolute; /* Вынимаем из потока, чтобы не двигать Spark */
    left: 100%;        /* Появляется строго справа от 3D */
    top: 50%;
    transform: translateY(-50%); /* Идеальное центрирование по вертикали */
    padding-left: 20px; /* Чтобы курсор не сорвался при переходе на Flow */
    flex-direction: row;
    gap: 12px;
    margin: 0;
    z-index: 20;
}


/* Наследование стиля для всех элементов меню */
.submenu .menu-item, .submenu-item {
    font-size: 18px;
    opacity: 0.8;
}

/* Появление подменю */
.menu-item-container:hover .submenu {
    display: flex;
}

/* Подсветка родителя */
.menu-item-container:hover > .menu-item {
    color: #ffeb3b;
}

/* Поведение текста как ссылки */
span.menu-item {
    cursor: pointer;
    display: block;
}


.logo {
    max-width: 48px;
    height: auto;
    opacity: 0.8;
    pointer-events: auto;
    display: block;
    margin-bottom: 20px;
    transition: opacity 0.3s ease;
}

.logo:hover { opacity: 1; }

/* ----- Canvas ----- */
canvas {
    position: absolute;
    inset: 0;
    z-index: 1;
    display: block;
}

</style>
</head>

<body>

<div id="ui-layer">
    <a href="index.html"><img src="logo.png" alt="Logo" class="logo"></a>
<nav>
    <a href="cube.html" class="menu-item">Cube</a>
    <a href="spark.html" class="menu-item">Spark</a>
    <a href="book.html" class="menu-item">Book</a>
    <a href="flash.html" class="menu-item">Flash</a>
    <a href="clock.html" class="menu-item">Clock</a>
    <a href="code.html" class="menu-item">Code</a>
    <a href="size.html" class="menu-item">Size</a>
    <a href="peer.html" class="menu-item">Peer</a>

    <div style="margin-top: 20px" class="menu-item-container">
        <span class="menu-item">About</span>
        <div class="submenu">
            <a href="about.html" class="menu-item">Core</a>
            <a href="wire.html" class="menu-item">Wire</a>
            <a href="beta.html" class="menu-item">Beta</a>
        </div>
    </div> 
            <a href="resume.html" class="menu-item">Link</a>
</nav>
</div> 

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>

<script>
/* ===== СЦЕНА ===== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000088);

/* ===== КАМЕРА ===== */
const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.z = 35;

/* ===== РЕНДЕР ===== */
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ===== КОНТРОЛЫ ===== */
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* ===== СВЕТ ===== */
scene.add(new THREE.AmbientLight(0xffffff, 0.4));
[
    [0xff0000,  20,  15, 25],
    [0x00ff00, -20,  15, 25],
    [0x0000ff,   0, -25, 25]
].forEach(l => {
    const light = new THREE.PointLight(l[0], 2.5, 150);
    light.position.set(l[1], l[2], l[3]);
    scene.add(light);
});

/* ===== ЗВУК ===== */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playLaunchSound(power) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = "sawtooth";
    osc.frequency.value = 160 + power * 260;
    gain.gain.setValueAtTime(0.001, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.18, audioCtx.currentTime + 0.04);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.28);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.3);
}

let firstAutoSpawn = true;

function playSpawnSound() {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = "triangle";
    osc.frequency.value = 420 + Math.random() * 180;
    gain.gain.setValueAtTime(0.001, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.1, audioCtx.currentTime + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.22);
}

/* ===== ДАННЫЕ ===== */
const objects = [];
let preview = null;
let directionLine = null;
let isHolding = false;
let holdStart = 0;
let lastUserActivity = performance.now();
const mouse = new THREE.Vector2();

const minScale = 0.4;
const maxScale = 8;
const minOpacity = 0.25;
const maxOpacity = 0.9;

/* ===== РАЗРЫВ ===== */
function explode(obj) {
    const basePos = obj.position.clone();
    const baseMat = obj.material;
    const baseScale = obj.scale.x;

    for (let i = 0; i < 8; i++) {
        const geom = new THREE.IcosahedronGeometry(0.5, 0);
        const mat  = baseMat.clone();
        const piece = new THREE.Mesh(geom, mat);
        piece.position.copy(basePos);
        piece.scale.setScalar(baseScale);
        piece.userData.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.35,
            (Math.random() - 0.5) * 0.35,
            (Math.random() - 0.5) * 0.35
        );
        scene.add(piece);
        objects.push(piece);
    }
    scene.remove(obj);
}

/* ===== POINTER DOWN ===== */
window.addEventListener("pointerdown", e => {
    lastUserActivity = performance.now();
    isHolding = true;
    holdStart = performance.now();

    mouse.set(
        (e.clientX / innerWidth) * 2 - 1,
        -(e.clientY / innerHeight) * 2 + 1
    );

    const dir = new THREE.Vector3(mouse.x, mouse.y, 0.5)
        .unproject(camera)
        .sub(camera.position)
        .normalize();

    const pos = camera.position.clone().add(dir.clone().multiplyScalar(10));

    const geom = new THREE.IcosahedronGeometry(0.5, 0);
    const mat = new THREE.MeshPhongMaterial({
        color: Math.random() * 0xffffff,
        transparent: true,
        opacity: minOpacity,
        shininess: 120,
        side: THREE.DoubleSide
    });

    preview = new THREE.Mesh(geom, mat);
    preview.position.copy(pos);
    preview.scale.setScalar(minScale);
    preview.userData.dir = dir;
    scene.add(preview);

    directionLine = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([
            pos.clone(),
            pos.clone().add(dir.clone().multiplyScalar(6))
        ]),
        new THREE.LineBasicMaterial({ transparent: true, opacity: 0.4 })
    );
    scene.add(directionLine);
});

/* ===== POINTER UP ===== */
window.addEventListener("pointerup", () => {
    if (!preview) return;
    isHolding = false;
    lastUserActivity = performance.now();

    const holdTime = Math.min((performance.now() - holdStart) / 1000, 2);
    const power = holdTime / 2;

    preview.userData.velocity =
        preview.userData.dir.clone().multiplyScalar(0.12 + power * 0.35);

    playLaunchSound(power);

    const obj = preview;
    objects.push(obj);

    setTimeout(() => {
        if (scene.children.includes(obj)) explode(obj);
    }, 2000);

    if (directionLine) {
        scene.remove(directionLine);
        directionLine = null;
    }

    preview = null;
});

/* ===== СПОНТАННЫЕ ОБЪЕКТЫ ===== */

function spawnRandomObject() {

    let dir, pos;

    if (firstAutoSpawn) {
        // первый объект — в центре сцены
        pos = new THREE.Vector3(0, 0, 0);

        // направление — от камеры в центр
        dir = camera.getWorldDirection(new THREE.Vector3()).normalize();

        firstAutoSpawn = false;
    } else {
        // все остальные — как раньше
        dir = new THREE.Vector3(
            Math.random() * 2 - 1,
            Math.random() * 2 - 1,
            Math.random() * 2 - 1
        ).normalize();

        pos = dir.clone().multiplyScalar(8);
    }

    const geom = new THREE.IcosahedronGeometry(0.5, 0);
    const mat = new THREE.MeshPhongMaterial({
        color: Math.random() * 0xffffff,
        transparent: true,
        opacity: 0.6,
        shininess: 120,
        side: THREE.DoubleSide
    });

    const obj = new THREE.Mesh(geom, mat);
    obj.position.copy(pos);
    obj.scale.setScalar(0.8);
    obj.userData.velocity = dir.multiplyScalar(0.18);

    scene.add(obj);
    objects.push(obj);

    playSpawnSound();

    setTimeout(() => {
        if (scene.children.includes(obj)) explode(obj);
    }, 2000);
}

// Первый импульс — при старте
window.addEventListener('load', () => {
    spawnRandomObject(); 
});

// Второй импульс — строго один раз после первого действия пользователя
window.addEventListener('pointerup', () => {
    setTimeout(spawnRandomObject, 5000);
}, { once: false });



/* ===== АНИМАЦИЯ ===== */
function animate() {
    requestAnimationFrame(animate);

    objects.forEach(obj => {
        if (!obj.userData.velocity) return;
        obj.position.add(obj.userData.velocity);
        obj.userData.velocity.multiplyScalar(0.99);
        obj.rotation.x += 0.01;
        obj.rotation.y += 0.015;
    });

    if (isHolding && preview) {
        const t = Math.min((performance.now() - holdStart) / 2000, 1);
        const scale = THREE.MathUtils.lerp(minScale, maxScale, t);
        preview.scale.setScalar(scale);
        preview.material.opacity =
            THREE.MathUtils.lerp(maxOpacity, minOpacity, t);
        preview.rotation.x += 0.03;
        preview.rotation.y += 0.02;

        if (directionLine) {
            const p0 = preview.position;
            const p1 = p0.clone().add(preview.userData.dir.clone().multiplyScalar(6));
            directionLine.geometry.setFromPoints([p0, p1]);
        }
    }

    controls.update();
    renderer.render(scene, camera);
}

/* ===== RESIZE ===== */
window.addEventListener("resize", () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});

animate();
</script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js')
      .then(reg => console.log('Распорядитель на месте:', reg.scope))
      .catch(err => console.log('Служба дала сбой:', err));
  });
}

</body>
</html>
