<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<link rel="manifest" href="manifest.json">
<title>Virtual Sandbox</title>
<link href="https://fonts.googleapis.com/css2?family=Ubuntu&display=swap" rel="stylesheet">


<style>

body { 
    margin: 0; 
    padding: 0; 
    background-color: #000088; 
    overflow: hidden; 
    position: fixed; 
    inset: 0;
    -webkit-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
}

canvas {
    position: fixed !important; 
    top: 0;
    left: 0;
    width: 100% !important;
    height: 100% !important;
    z-index: 1; 
    display: block;
}



#ui-layer { 
    position: fixed; 
    inset: 0; /* Растягивает на весь экран: top, left, right, bottom = 0 */
    z-index: 10;
    padding: 40px 0 40px 3%; 
    pointer-events: none; 
    display: flex;
    flex-direction: column;
    box-sizing: border-box;
}


nav {
    display: flex;
    flex-direction: column;
    gap: 8px;
    width: fit-content;
    pointer-events: none; /* Все еще пропускаем клики в пустых местах навигации */
}

.menu-item-container {
    display: flex;
    flex-direction: row; 
    align-items: center;
    position: relative; 
    width: fit-content;
    pointer-events: auto; /* А вот здесь — разрешаем клики (на кнопках и подменю) */
}

.menu-item { 
    text-decoration: none;
    color: #ffffff;
    font-family: 'Ubuntu', sans-serif;
    font-size: 18px;
    letter-spacing: 0px;
    opacity: 0.8;
    white-space: nowrap;
    padding-left: 2px;
    pointer-events: auto;
    cursor: pointer;
    display: block;

    transition: transform 0.2s ease, color 0.2s ease;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5); 
}




/* Явно разрешаем клики только там, где есть контент */
.logo, .menu-item, .submenu {
    pointer-events: auto;
}


.menu-item:hover {
    color: #ffeb3b;
    transform: scale(1.08);
}

/* ОБНОВЛЕННЫЙ БЛОК ПОДМЕНЮ */
.submenu {
    display: none;
        font-family: 'Ubuntu';
    position: absolute; /* Вынимаем из потока, чтобы не двигать Spark */
    left: 100%;        /* Появляется строго справа от 3D */
    top: 50%;
    transform: translateY(-50%); /* Идеальное центрирование по вертикали */
    padding-left: 20px; /* Чтобы курсор не сорвался при переходе на Flow */
    flex-direction: row;
    gap: 12px;
    margin: 0;
    z-index: 20;
}


/* Наследование стиля для всех элементов меню */
.submenu .menu-item, .submenu-item {
    font-size: 18px;
    opacity: 0.8;
}

/* Появление подменю */
.menu-item-container:hover .submenu {
    display: flex;
}

/* Подсветка родителя */
.menu-item-container:hover > .menu-item {
    color: #ffeb3b;
}

/* Поведение текста как ссылки */
span.menu-item {
    cursor: pointer;
    display: block;
}


.logo {
    max-width: 64px;
    height: auto;
    opacity: 0.9;
    pointer-events: auto;
    display: block;
    margin-bottom: 5px;
    transition: opacity 0.3s ease;
}

.logo:hover { opacity: 1; }

#ui-layer, nav, .menu-item {
    touch-action: manipulation;
}


/* Стили для блока Support */
.donate-box { 
    display: flex; 
    flex-direction: column; 
    gap: 10px; 
    margin-top: 20px;

    width: fit-content;

    pointer-events: auto; /* Важно: разрешаем клики */
}

.donate-btn { 
    color: rgba(255,255,255,0.6); 
    border: 1px solid rgba(255,255,255,0.3); 
    padding: 8px 16px; 
    background: transparent; 
    cursor: pointer; 
    font-size: 12px; 
    font-family: 'Ubuntu';
    transition: 0.3s; 
    border-radius: 8px; 
    width: fit-content;
}

.donate-btn:hover { 
    background: #ffeb3b; 
    color: #000; 
    border-color: #ffeb3b;
}

.donate-container {
    display: flex;
    flex-direction: column;
    align-items: flex-start; /* Keeps Support at the 3% line */
    width: fit-content;
}

.crypto-info { 
    display: none; 
    flex-direction: column;
    gap: 8px;
    padding: 10px 0 20px 2px; /* 20px gap + 2px item padding */
    margin: 0;
    align-self: flex-start;
}

/* Find this block or add it */
.donate-container {
    display: flex !important;
    flex-direction: column !important; /* Forces info BELOW the word Support */
    align-items: flex-start !important;
}


.crypto-info, 
.crypto-info span { 
    font-family: 'Ubuntu', sans-serif !important;
    font-weight: normal;
}




.crypto-address-display { 
    font-size: 10px; 
    color: #fff; 
    background: rgba(255,255,255,0.05); 
    padding: 8px; 
    border: 1px dashed rgba(255,255,255,0.3); 
    cursor: copy; 
    word-break: break-all; 
    max-width: 200px;
}


.crypto-address-display { 
    font-size: 10px; 
    color: #fff; 
    background: rgba(255,255,255,0.05); 
    padding: 8px; 
    border: 1px dashed rgba(255,255,255,0.9); 
    cursor: copy; 
    word-break: break-all; 
    max-width: 300px;
    font-family: 'Ubuntu';
}

</style> 
</head>

<body>

<div id="ui-layer">
<div style="width: fit-content; pointer-events: auto;">
    <a style="margin-bottom: 15px; display: block;" href="index.html">
        <img src="logo.png" alt="Logo" class="logo">
    </a>
</div>

<nav>
        <div style="margin-top: 10px" class="menu-item-container">
        <span class="menu-item">Object</span>
        <div class="submenu">
        <a href="cube.html" class="menu-item">Cube</a>
    <a href="peer.html" class="menu-item">Peer</a>
                <a href="drop.html" class="menu-item">Drop</a>
                            <a href="sharp.html" class="menu-item">Sharp</a>
        </div>
    </div> 

        
        <div style="margin-top: 10px" class="menu-item-container">
        <span class="menu-item">Core</span>
        <div class="submenu">
    <a href="square.html" class="menu-item">Square</a>
    <a href="spark.html" class="menu-item">Spark</a>
    <a href="clock.html" class="menu-item">Clock</a>
        </div>
    </div> 

        <div style="margin-top: 10px" class="menu-item-container">
        <span class="menu-item">Word</span>
        <div class="submenu">
    <a href="matrix.html" class="menu-item">Matrix</a>
    <a href="book.html" class="menu-item">Book</a>
    <a href="flash.html" class="menu-item">Flash</a>
    <a href="loop.html" class="menu-item">Loop</a>
        </div>
    </div> 
    

    
       <div style="margin-top: 10px" class="menu-item-container">
        <span class="menu-item">Type</span>
        <div class="submenu">
    <a href="code.html" class="menu-item">Code</a>
    <a href="size.html" class="menu-item">Size</a>
        </div>
    </div> 
    


    <div style="margin-top: 10px" class="menu-item-container">
        <span class="menu-item">More</span>
        <div class="submenu">
            <a href="beta.html" class="menu-item">Beta</a>
            <a href="demo.html" class="menu-item">Demo</a>
            <a href="quant.html" class="menu-item">Quant</a>

        </div>
    </div> 
    
    <div style="margin-top: 10px" class="menu-item-container">
        <span class="menu-item">Link</span>
        <div class="submenu">
        <a href="wire.html" class="menu-item">Wire</a>
        <a href="resume.html" class="menu-item">Resume</a>
        <a href="https://t.me/eugenebox" class="menu-item">Feedback</a>
        </div>
    </div> 

<div style="margin-top: 10px" class="menu-item-container donate-container">
    <span class="menu-item" onclick="toggleDonate()">Support</span>
    <div id="cryptoInfo" class="crypto-info">
        <span style="font-size: 11px; color: #fff;">USDT BSC (BEP20)</span>
        <div id="cryptoAddr" class="crypto-address-display" onclick="copyToClipboard()">0x769192cea8fbb7207f086d95fd653ebc3adb0c72</div>
        <span id="copyHint" style="font-size: 10px; color: #fff;">Click to copy address</span>
    </div>
</div>

</nav>
</div> 

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>

<script>
/* ===== СЦЕНА ===== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000088);

/* ===== КАМЕРА ===== */
const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
camera.position.z = 35;

/* ===== РЕНДЕР ===== */
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);

// Это — команда «встать в координаты 0,0 и игнорировать соседей»
renderer.domElement.style.position = 'fixed';
renderer.domElement.style.top = '0';
renderer.domElement.style.left = '0';
renderer.domElement.style.width = '100vw';
renderer.domElement.style.height = '100vh';
renderer.domElement.style.zIndex = '1'; 

document.body.appendChild(renderer.domElement);


/* ===== КОНТРОЛЫ ===== */
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* ===== СВЕТ ===== */
// Общий заполняющий свет, чтобы сцена не была слишком контрастной
const ambient = new THREE.AmbientLight(0xffffff, 0.8);
scene.add(ambient);

// Красный свет слева
const redSun = new THREE.DirectionalLight(0xff0000, 1.5);
redSun.position.set(-50, 20, 20);
scene.add(redSun);

// Зеленый свет справа
const greenSun = new THREE.DirectionalLight(0x00ff00, 1.5);
greenSun.position.set(50, 20, 20);
scene.add(greenSun);

// Синий свет снизу или сзади
const blueSun = new THREE.DirectionalLight(0x0000ff, 1.5);
blueSun.position.set(0, -50, 20);
scene.add(blueSun);



/* ===== ЗВУК ===== */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playLaunchSound(power) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = "sawtooth";
    osc.frequency.value = 160 + power * 260;
    gain.gain.setValueAtTime(0.001, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.18, audioCtx.currentTime + 0.04);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.28);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.3);
}

let firstAutoSpawn = true;

function playSpawnSound() {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = "triangle";
    osc.frequency.value = 420 + Math.random() * 180;
    gain.gain.setValueAtTime(0.001, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.1, audioCtx.currentTime + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.22);
}

/* ===== ДАННЫЕ ===== */
const objects = [];
let preview = null;
let directionLine = null;
let isHolding = false;
let holdStart = 0;
let lastUserActivity = performance.now();
const mouse = new THREE.Vector2();

const minScale = 0.01;
const maxScale = 21;
const minOpacity = 0.25;
const maxOpacity = 0.9;

/* ===== РАЗРЫВ ===== */
function explode(obj) {
    const basePos = obj.position.clone();
    const baseMat = obj.material;
    const baseScale = obj.scale.x;

    for (let i = 0; i < 8; i++) {
        const geom = new THREE.IcosahedronGeometry(0.5, 0);
        const mat  = baseMat.clone();
        const piece = new THREE.Mesh(geom, mat);
        piece.position.copy(basePos);
        piece.scale.setScalar(baseScale);
     // Мы берем baseScale (масштаб объекта) и используем его как множитель энергии взрыва
const power = baseScale * 0.15; 

piece.userData.velocity = new THREE.Vector3(
    (Math.random() - 0.5) * power,
    (Math.random() - 0.5) * power,
    (Math.random() - 0.5) * power
);

        scene.add(piece);
        objects.push(piece);
    }
    scene.remove(obj);
}

/* ===== POINTER DOWN ===== */
window.addEventListener("pointerdown", e => {
    lastUserActivity = performance.now();
    isHolding = true;
    holdStart = performance.now();

    mouse.set(
        (e.clientX / innerWidth) * 2 - 1,
        -(e.clientY / innerHeight) * 2 + 1
    );

    const dir = new THREE.Vector3(mouse.x, mouse.y, 0.5)
        .unproject(camera)
        .sub(camera.position)
        .normalize();

    const pos = camera.position.clone().add(dir.clone().multiplyScalar(10));

    const geom = new THREE.IcosahedronGeometry(0.5, 0);
    const mat = new THREE.MeshPhongMaterial({
        color: Math.random() * 0xffffff,
        transparent: true,
        opacity: minOpacity,
        shininess: 120,
        side: THREE.DoubleSide
    });

    preview = new THREE.Mesh(geom, mat);
    preview.position.copy(pos);
    preview.scale.setScalar(minScale);
    preview.userData.dir = dir;
    scene.add(preview);

    directionLine = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([
            pos.clone(),
            pos.clone().add(dir.clone().multiplyScalar(6))
        ]),
        new THREE.LineBasicMaterial({ transparent: true, opacity: 0.4 })
    );
    scene.add(directionLine);
});

/* ===== POINTER UP ===== */
window.addEventListener("pointerup", () => {
    if (!preview) return;
    isHolding = false;
    lastUserActivity = performance.now();

    const holdTime = Math.min((performance.now() - holdStart) / 1000, 2);
    const power = holdTime / 8;

    // Получаем текущий масштаб объекта (он уже вырос в функции animate)
const currentScale = preview.scale.x;

// Рассчитываем скорость: чем больше масштаб, тем выше множитель расстояния
// 0.05 — базовый коэффициент, который можно подправить для нужной дальности
preview.userData.velocity = 
    preview.userData.dir.clone().normalize().multiplyScalar((0.2 + power * 0.35) * currentScale * 0.8);

    playLaunchSound(power);

    const obj = preview;
    objects.push(obj);

    setTimeout(() => {
        if (scene.children.includes(obj)) explode(obj);
    }, 2000);

    if (directionLine) {
        scene.remove(directionLine);
        directionLine = null;
    }

    preview = null;
});

/* ===== СПОНТАННЫЕ ОБЪЕКТЫ ===== */

function spawnRandomObject() {

    let dir, pos;

    if (firstAutoSpawn) {
        // первый объект — в центре сцены
        pos = new THREE.Vector3(0, 0, 0);

        // направление — от камеры в центр
        dir = camera.getWorldDirection(new THREE.Vector3()).normalize();

        firstAutoSpawn = false;
    } else {
        // все остальные — как раньше
        dir = new THREE.Vector3(
            Math.random() * 2 - 1,
            Math.random() * 2 - 1,
            Math.random() * 2 - 1
        ).normalize();

        pos = dir.clone().multiplyScalar(8);
    }

    const geom = new THREE.IcosahedronGeometry(0.5, 0);
    const mat = new THREE.MeshPhongMaterial({
        color: Math.random() * 0xffffff,
        transparent: true,
        opacity: 0.6,
        shininess: 120,
        side: THREE.DoubleSide
    });

    const obj = new THREE.Mesh(geom, mat);
    obj.position.copy(pos);
    obj.scale.setScalar(0.8 + Math.random() * 2.0);
    obj.userData.velocity = dir.multiplyScalar(0.18);

    scene.add(obj);
    objects.push(obj);

    playSpawnSound();

    setTimeout(() => {
        if (scene.children.includes(obj)) explode(obj);
    }, 2000);
}

// Первый импульс — при старте
window.addEventListener('load', () => {
    spawnRandomObject(); 
});

// Второй импульс — строго один раз после первого действия пользователя
window.addEventListener('pointerup', () => {
    setTimeout(spawnRandomObject, 5000);
}, { once: false });



/* ===== АНИМАЦИЯ ===== */
function animate() {
    requestAnimationFrame(animate);

    objects.forEach(obj => {
        if (!obj.userData.velocity) return;
        obj.position.add(obj.userData.velocity);
        obj.userData.velocity.multiplyScalar(0.99);
        obj.rotation.x += 0.01;
        obj.rotation.y += 0.015;
    });

    if (isHolding && preview) {
        const t = Math.min((performance.now() - holdStart) / 2000, 1);
        const scale = THREE.MathUtils.lerp(minScale, maxScale, t);
        preview.scale.setScalar(scale);
        preview.material.opacity =
            THREE.MathUtils.lerp(maxOpacity, minOpacity, t);
        preview.rotation.x += 0.03;
        preview.rotation.y += 0.02;

        if (directionLine) {
            const p0 = preview.position;
            const p1 = p0.clone().add(preview.userData.dir.clone().multiplyScalar(6));
            directionLine.geometry.setFromPoints([p0, p1]);
        }
    }

    controls.update();
    renderer.render(scene, camera);
}

/* ===== RESIZE ===== */
/* ===== RESIZE ===== */
window.addEventListener("resize", () => {
    const w = window.innerWidth;
    const h = window.innerHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
    // Принудительно обновляем стили холста, чтобы он не схлопнулся
    renderer.domElement.style.width = '100vw';
    renderer.domElement.style.height = '100vh';
});


animate();
/* ===== БЛОКИРОВКА DOUBLE-TAP ZOOM ===== */
let lastTouchEnd = 0;
document.addEventListener('touchend', (event) => {
    const now = (new Date()).getTime();
    if (now - lastTouchEnd <= 300) {
        event.preventDefault();
    }
    lastTouchEnd = now;
}, false);

function toggleDonate() { 
    const info = document.getElementById("cryptoInfo"); 
    const body = document.body;
    const isOpening = (window.getComputedStyle(info).display === "none");
    
    if (isOpening) {
        info.style.display = "flex";
        body.classList.add('allow-scroll');
        
        // Плавная прокрутка к появившемуся адресу
        setTimeout(() => {
            info.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }, 100);
    } else {
        info.style.display = "none";
        body.classList.remove('allow-scroll');
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
}

function copyToClipboard() {
    const addr = document.getElementById("cryptoAddr");
    const text = addr.innerText;
    if (text === "Copied!") return;

    navigator.clipboard.writeText(text).then(() => {
        const oldText = text;
        addr.innerText = "Copied!";
        addr.style.color = "#ffeb3b";
        setTimeout(() => {
            addr.innerText = oldText;
            addr.style.color = "#fff";
        }, 1500);
    });
}

if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js')
      .then(reg => console.log('Распорядитель на месте:', reg.scope))
      .catch(err => console.log('Служба дала сбой:', err));
  });
}

</script>

</body>
</html>
