<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
        <link rel="manifest" href="manifestdrop.json">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<style>
    * { 
        -webkit-tap-highlight-color: transparent; 
        touch-action: none !important; 
        user-select: none !important; 
    }
    body, html { 
        margin: 0; padding: 0; width: 100%; height: 100%; 
        overflow: hidden; background: #000; position: fixed; 
    }
    canvas { display: block; width: 100%; height: 100%; }

    /* Контейнер интерфейса */
    .ui-overlay {
        position: fixed;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        pointer-events: none;
        z-index: 1000;
    }

    .ui-overlay > * { pointer-events: auto; }

    header {
        width: 100%;
        text-align: center;
        padding-top: 20px;
        background: linear-gradient(to bottom, rgba(0,0,0,0.5) 0%, transparent 100%);
    }

    .bottom-ui {
        margin-top: auto;
        padding-bottom: 30px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 30px;
        width: 100%;
    }

    .menu-links { display: flex; gap: 20px; font-family: sans-serif; }
    .menu-links a { color: #fff; text-decoration: none; transition: opacity 0.3s; }

    /* Support Styles */
    .donate-box { display: flex; flex-direction: column; align-items: center; }
    .donate-btn { 
        color: #fff; border: 1px solid #fff; padding: 5px 15px; 
        background: transparent; cursor: pointer; font-family: sans-serif; 
        font-size: 12px; transition: 0.3s; 
    }
    .donate-btn:hover { background: #fff; color: #000; }
    
    .crypto-info { 
        display: none; flex-direction: column; align-items: center; 
        gap: 5px; margin-top: 15px; background: rgba(0,0,0,0.85); 
        padding: 10px; border-radius: 5px; 
    }
    .crypto-address-display { 
        font-size: 10px; color: #fff; background: #111; 
        padding: 8px 12px; border: 1px dashed #fff; 
        cursor: copy; word-break: break-all; max-width: 240px; 
        font-family: monospace;
    }
</style>

</head>
<body oncontextmenu="return false;">
<div class="ui-overlay">
    <header>
        <a href="index.html" style="display: inline-block; width: 48px; margin-bottom: 10px;">
            <img src="logo.png" alt="Logo" style="width: 100%; height: auto;">
        </a>
        <h1 style="color: #fff; font-family: sans-serif; margin: 0; font-size: 24px; letter-spacing: 1px;">Liquid Zen</h1>
        <p style="color: rgba(255,255,255,0.6); font-family: sans-serif; margin: 5px 0 0 0; font-size: 10px; text-transform: uppercase; letter-spacing: 4px;">Droplet Lab</p>
    </header>

    <div class="bottom-ui">
        <div class="menu-links">
            <a href="drop.html" style="opacity: 0.6;">Drop</a>
            <a href="sharp.html" style="opacity: 0.6;">Sharp</a>
            <a href="blob.html" style="opacity: 0.6;">Blob</a>
            <a href="wave.html" style="opacity: 0.6;">Wave</a>
            <a href="ray.html" style="font-weight: bold; opacity: 1;">Ray</a>
        </div>

        <div class="donate-box">
            <button class="donate-btn" onclick="toggleDonate()">Support</button>
            <div id="cryptoInfo" class="crypto-info">
                <span style="font-size: 10px; color: #fff; margin-bottom: 4px;">USDT BSC (BEP20)</span>
                <div id="cryptoAddr" class="crypto-address-display" onclick="copyToClipboard()">0x769192cea8fbb7207f086d95fd653ebc3adb0c72</div>
                <span id="copyHint" style="font-size: 9px; color: #fff; margin-top: 4px;">Click address to copy</span>
            </div>
        </div>
    </div>
</div>


      <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script>
        let scene, camera, renderer, mainGroup, droplets = [];
        let touches = {}; 
        let prevTouchDist = null;
        let isDragging = false;
        let longPressTimer = null;
        let startPos = { x: 0, y: 0 };
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        const geo = new THREE.IcosahedronGeometry(0.8, 64); 
        const originalPos = geo.attributes.position.array.slice();
        const mat = new THREE.MeshPhysicalMaterial({
            color: 0x3399ff, metalness: 0.2, roughness: 0.1, transmission: 0.7, transparent: true
        });

        function createDroplet(x, y, z) {
            const g = geo.clone();
            const drop = new THREE.Mesh(g, mat);
            drop.position.set(x, y, z);
            drop.userData = { hits: [], base: originalPos.slice() };
            mainGroup.add(drop);
            droplets.push(drop);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const p1 = new THREE.PointLight(0xff0000, 10); p1.position.set(5, 5, 5); scene.add(p1);
            const p2 = new THREE.PointLight(0x00ff00, 10); p2.position.set(-5, 5, 5); scene.add(p2);

            createDroplet(0, 0, 0);

            const canvas = renderer.domElement;

            const preventAll = (e) => {
                if (e.cancelable) e.preventDefault();
                e.stopPropagation();
            };

            canvas.addEventListener('touchstart', (e) => {
                preventAll(e);
                isDragging = true;
                const t = e.touches[0];
                startPos = { x: t.clientX, y: t.clientY };
                
                for (let touch of e.touches) touches[touch.identifier] = { x: touch.clientX, y: touch.clientY };

                if (e.touches.length === 1) {
                    mouse.x = (t.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(t.clientY / window.innerHeight) * 2 + 1;

                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(droplets);

                    longPressTimer = setTimeout(() => {
                        if (intersects.length > 0) {
                            const obj = intersects[0].object;
                            mainGroup.remove(obj);
                            droplets = droplets.filter(d => d !== obj);
                        }
                        longPressTimer = null;
                    }, 600);
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                preventAll(e);
                if (!isDragging) return;
                
                const t0 = e.touches[0];
                if (Math.hypot(t0.clientX - startPos.x, t0.clientY - startPos.y) > 10) {
                    if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
                }

                if (e.touches.length === 1) {
                    const t = e.touches[0];
                    const prev = touches[t.identifier];
                    mainGroup.rotation.y += (t.clientX - prev.x) * 0.01;
                    mainGroup.rotation.x += (t.clientY - prev.y) * 0.01;
                } 
                else if (e.touches.length === 2) {
                    const t1 = e.touches[0], t2 = e.touches[1];
                    const curDist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
                    if (prevTouchDist) camera.position.z = Math.max(2, Math.min(15, camera.position.z - (curDist - prevTouchDist) * 0.01));
                    prevTouchDist = curDist;
                }

                for (let touch of e.touches) touches[touch.identifier] = { x: touch.clientX, y: touch.clientY };
            }, { passive: false });

            canvas.addEventListener('touchend', (e) => {
                preventAll(e);
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(droplets);
                    
                    if (intersects.length > 0) {
                        const hit = intersects[0];
                        hit.object.userData.hits.push({
                            pos: hit.object.worldToLocal(hit.point.clone()),
                            strength: 3.5,
                            active: true
                        });
                    } else {
                        const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5).unproject(camera);
                        const dir = vector.sub(camera.position).normalize();
                        const distance = -camera.position.z / dir.z;
                        const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                        const localPos = mainGroup.worldToLocal(pos);
                        createDroplet(localPos.x, localPos.y, localPos.z);
                    }
                }

                if (e.touches.length === 0) {
                    isDragging = false;
                    prevTouchDist = null;
                    touches = {};
                }
                longPressTimer = null;
            }, { passive: false });

            animate();
        }


        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.0005;
            
            // Получаем позицию камеры для расчета физики отталкивания
            const camPos = new THREE.Vector3();
            camera.getWorldPosition(camPos);

            droplets.forEach(drop => {
                const pos = drop.geometry.getAttribute('position');
                const ud = drop.userData;

                // --- ФИЗИКА СБЛИЖЕНИЯ И ОТТАЛКИВАНИЯ (ДОБАВЛЕНО) ---
                const dropPos = new THREE.Vector3();
                drop.getWorldPosition(dropPos);
                
                // 1. Отталкивание от камеры, если она слишком близко
                const dist = dropPos.distanceTo(camPos);
                if (dist < 4) {
                    const force = (4 - dist) * 0.03;
                    drop.position.add(dropPos.sub(camPos).normalize().multiplyScalar(force));
                }

                // 2. Дрейф к центру (сближение всех объектов в одну точку)
                drop.position.multiplyScalar(0.99); 
                // --------------------------------------------------

                ud.hits = ud.hits.filter(h => h.strength > 0.001);

                for (let i = 0; i < pos.count; i++) {
                    const vx = ud.base[i*3], vy = ud.base[i*3+1], vz = ud.base[i*3+2];
                    const v = new THREE.Vector3(vx, vy, vz);
                    let totalPush = 0;

                    ud.hits.forEach(hit => {
                        const d = v.distanceTo(hit.pos);
                        const area = Math.exp(-d * 40.0);
                        const taper = Math.pow(Math.max(0, 1 - d * 2.5), 4);
                        totalPush += hit.strength * area * taper;
                    });

                    v.normalize().multiplyScalar(0.8 + totalPush);
                    v.addScaledVector(v, Math.sin(vx * 8 + time) * 0.008);
                    pos.setXYZ(i, v.x, v.y, v.z);
                }

                ud.hits.forEach(h => { h.strength *= 0.985; });

                pos.needsUpdate = true;
                drop.geometry.computeVertexNormals();
            });
            renderer.render(scene, camera);
        }


        init();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        function toggleDonate() { 
    const info = document.getElementById("cryptoInfo"); 
    info.style.display = (info.style.display === "flex") ? "none" : "flex"; 
}

function copyToClipboard() {
    const addr = document.getElementById("cryptoAddr");
    const hint = document.getElementById("copyHint");
    const text = addr.innerText;
    navigator.clipboard.writeText(text).then(() => {
        addr.innerText = "Copied!";
        addr.style.color = "#00ff00";
        if (hint) hint.innerText = "Address saved to clipboard";
        setTimeout(() => {
            addr.innerText = text;
            addr.style.color = "#fff";
            if (hint) hint.innerText = "Click address to copy";
        }, 1500);
    });
}

    </script>
</body>
</html>
